{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Evaluate a bird song network"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%config InlineBackend.figure_format = 'jpg'  # smaller mem footprint for page\n",
    "\n",
    "import zarr\n",
    "import librosa.feature, librosa.display\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import colorcet as cc\n",
    "import sklearn.metrics\n",
    "import scipy.stats\n",
    "from matplotlib.colors import ListedColormap\n",
    "\n",
    "import das.utils, das.utils_plot, das.predict, das.data, das.models, das.train, das.io, das.evaluate, das.segment_utils\n",
    "\n",
    "plt.style.use('ncb.mplstyle')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Load data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "ename": "FileNotFoundError",
     "evalue": "[Errno 2] No such file or directory: '/Users/janc/Dropbox/dss.paper/sober/20200418_215107_params.yaml'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-2-43f51740f1eb>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0msavename\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m'/Users/janc/Dropbox/dss.paper/sober/20200418_215107'\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m \u001b[0mparams\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdas\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mutils\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mload_params\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msavename\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      3\u001b[0m \u001b[0mstore\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mzarr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msavename\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m'.zarr'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0mfs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m32_000\u001b[0m  \u001b[0;31m# Hz\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Volumes/shinkansen/Dropbox/code.py/das/src/das/utils.py\u001b[0m in \u001b[0;36mload_params\u001b[0;34m(file_trunk, params_ext)\u001b[0m\n\u001b[1;32m    125\u001b[0m     \"\"\"\n\u001b[1;32m    126\u001b[0m     \u001b[0mfilename\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_download_if_url\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile_trunk\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mparams_ext\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 127\u001b[0;31m     \u001b[0;32mwith\u001b[0m \u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfilename\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'r'\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mf\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    128\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    129\u001b[0m             \u001b[0mparams\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0myaml\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mload\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mLoader\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0myaml\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mFullLoader\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: '/Users/janc/Dropbox/dss.paper/sober/20200418_215107_params.yaml'"
     ]
    }
   ],
   "source": [
    "savename = '/Users/janc/Dropbox/dss.paper/sober/20200418_215107'\n",
    "params = das.utils.load_params(savename)\n",
    "store = zarr.open(savename + '.zarr')\n",
    "\n",
    "fs = 32_000  # Hz\n",
    "# sequence of ints - \"0\" if no song, >0 if syllable \n",
    "# labels_pred = store['labels_pred'][:fs * 500]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "save_name = '/Users/janc/Dropbox/dss.paper/models/sober_allInd/20200418_215107'\n",
    "\n",
    "gap_dur = 5 / 1000  # 5 ms\n",
    "min_len = 30 / 1000  # 30 ms\n",
    "\n",
    "# x_test = store['x_test'][:]\n",
    "# events, segments, y_pred = das.predict.predict(x_test[:fs * 500], model_save_name=save_name, verbose=1, segment_minlen=min_len, segment_fillgap=gap_dur)\n",
    "# np.save('confidence_scores.npy', y_pred)\n",
    "\n",
    "y_pred = np.load('confidence_scores.npy')#[:1_000_000]\n",
    "\n",
    "labels_test = store['labels_test'][:y_pred.shape[0]]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Predict syllable labels\n",
    "Based on majority vote"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# get true syllable labels from predictions\n",
    "_, segments_pred = das.predict.predict_song(y_pred, params, \n",
    "                                            segment_minlen=min_len,\n",
    "                                            segment_fillgap=gap_dur)\n",
    "\n",
    "# get true syllable labels from training targets\n",
    "_, segments_test = das.predict.predict_song(labels_test, params,\n",
    "                                            segment_minlen=min_len,\n",
    "                                            segment_fillgap=gap_dur)\n",
    "\n",
    "# re-run, using the on- and offsets of predicted syllables as a reference for determining the \"true\" labels\n",
    "_, segments_test_pred = das.predict.predict_song(labels_test, params,\n",
    "                                            segment_ref_onsets=segments_pred['onsets_seconds'],\n",
    "                                            segment_ref_offsets=segments_pred['offsets_seconds'],\n",
    "                                            segment_minlen=min_len,\n",
    "                                            segment_fillgap=gap_dur)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "labels_pred = segments_pred['samples']\n",
    "labels_test = segments_test['samples']\n",
    "min_len = min(len(labels_test), len(labels_pred))\n",
    "\n",
    "labels_pred = labels_pred[:min_len]\n",
    "labels_test = labels_test[:min_len]\n",
    "\n",
    "syllable_true_pred = segments_test_pred['sequence']\n",
    "syllable_pred_pred = segments_pred['sequence']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Inspect data and predictions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "t0 = 532_000 \n",
    "t1 = t0 + 60_000\n",
    "\n",
    "x = store['x_test'][t0:t1,0]\n",
    "\n",
    "T = np.arange(len(x))/fs\n",
    "hop_length = 100\n",
    "specgram = librosa.feature.melspectrogram(x, sr=32_000, n_fft=512+256, hop_length=hop_length, power=1)\n",
    "specgram = librosa.amplitude_to_db(specgram, np.max)\n",
    "labels_all = np.stack((labels_pred[t0:t1].T, labels_test[t0:t1].T))\n",
    "labels_all = np.unique(labels_all, return_inverse=True)[1].reshape((2, -1))\n",
    "\n",
    "cmap = cc.palette['glasbey_light'][1::2]\n",
    "cmap = list(cmap)[:12]\n",
    "cmap.insert(0, (0.9, 0.9, 0.9))\n",
    "cmap = ListedColormap(cmap)\n",
    "\n",
    "plt.gcf().set_size_inches(20, 10)\n",
    "plt.subplot(913)\n",
    "plt.plot(T, x, c='k', linewidth=0.5)\n",
    "plt.axis('tight')\n",
    "das.utils_plot.scalebar(.1, units='seconds', location='center left',\n",
    "                        font_properties={'size': 7})\n",
    "das.utils_plot.remove_axes(all=True)\n",
    "\n",
    "\n",
    "ax = plt.subplot(312)\n",
    "im = librosa.display.specshow(specgram, \n",
    "                            sr=32_000, hop_length=hop_length, y_axis='mel', x_axis='s', \n",
    "                            cmap=ListedColormap(list((cc.CET_L17))))\n",
    "freqs = 1000 * 2.0 ** np.arange(-1, 4)\n",
    "plt.yticks(freqs, freqs/1000)\n",
    "plt.ylim(300)\n",
    "plt.ylabel('Frequency [kHz]')\n",
    "plt.clim(-70, 0)\n",
    "ax.spines['bottom'].set_visible(False)\n",
    "plt.xticks(())\n",
    "plt.xlabel(None)\n",
    "\n",
    "ax = plt.subplot(18,1, 13)\n",
    "plt.imshow(labels_all, cmap=cmap)\n",
    "plt.axhline(0.5, c='k', alpha=0.1)\n",
    "plt.yticks((0, 1), labels=['Manual', 'DAS']);\n",
    "ax.spines['bottom'].set_visible(False)\n",
    "plt.xticks(())\n",
    "das.utils_plot.remove_axes()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Performance metrics\n",
    "### Sample-wise"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "cr = sklearn.metrics.classification_report(labels_test[::10], labels_pred[::10], \n",
    "                                           output_dict=False,\n",
    "                                           labels=np.arange(1, 50))\n",
    "print(cr)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Syllable labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "conf_mat_pred = sklearn.metrics.confusion_matrix(syllable_true_pred[syllable_true_pred!=26],\n",
    "                            syllable_pred_pred[syllable_true_pred!=26],\n",
    "                            labels=np.arange(0, 50))\n",
    "# remove syllables not in the test set\n",
    "good_sylls = np.sum(conf_mat_pred, axis=0)>1\n",
    "good_sylls[0] = True  # include 0 to depict false positives and false negatives\n",
    "conf_mat_pred = conf_mat_pred[good_sylls,:]\n",
    "conf_mat_pred = conf_mat_pred[:, good_sylls]\n",
    "\n",
    "plt.gcf().set_size_inches(8.5, 2)\n",
    "plt.subplot(131)\n",
    "plt.imshow(conf_mat_pred / np.sum(conf_mat_pred, axis=0), cmap='gray_r')\n",
    "plt.colorbar()\n",
    "plt.ylabel('Manual')\n",
    "plt.xlabel('DAS')\n",
    "\n",
    "plt.subplot(132)\n",
    "plt.imshow(np.log2(conf_mat_pred / np.sum(conf_mat_pred, axis=0)), cmap='gray_r')\n",
    "plt.colorbar()\n",
    "plt.title('Log scaled')\n",
    "plt.show()\n",
    "\n",
    "print('Micro avg', np.nanmean(np.diag(conf_mat_pred / np.nansum(conf_mat_pred, axis=0))))\n",
    "print('Global avg', np.nansum(np.diag(conf_mat_pred)) / np.nansum(conf_mat_pred))\n",
    "print(conf_mat_pred.shape)\n",
    "\n",
    "# syllable \"26\" is mislabelled\n",
    "syllable_true_pred[syllable_true_pred==26] = 0\n",
    "syllable_pred_pred[syllable_true_pred==26] = 0\n",
    "\n",
    "cr = sklearn.metrics.classification_report(syllable_true_pred[syllable_true_pred>0], \n",
    "                                           syllable_pred_pred[syllable_true_pred>0],\n",
    "                                           output_dict=False)\n",
    "print(cr)\n",
    "print('FN rate (%) ', 100*np.mean(syllable_true_pred==0), 100*np.mean(syllable_pred_pred==0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Timing of syllable on- and offsets "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "tol = 0.01  # seconds\n",
    "nn_dist_all = np.zeros((0,))\n",
    "\n",
    "for ii in range(2):\n",
    "    if ii==1:\n",
    "        times_test = segments_test['onsets_seconds']  # event_onsets_true\n",
    "        times_pred = segments_pred['onsets_seconds']  # event_onsets_pred\n",
    "        print({\"ONSETS:\"})\n",
    "    else:\n",
    "        times_test = segments_test['offsets_seconds']  # event_offsets_true\n",
    "        times_pred = segments_pred['offsets_seconds']  # event_offsets_pred\n",
    "        print({\"OFFSETS:\"})\n",
    "\n",
    "    d, nn_pred_pulse, nn_true_pulse, nn_dist = das.event_utils.evaluate_eventtimes(times_test, times_pred, fs, tol)\n",
    "    \n",
    "    print(f\"   FP {d['FP']}, TP {d['TP']}, FN {d['FN']}\")\n",
    "    print(f\"   precision {d['precision']:1.2f}, recall {d['recall']:1.2f}, f1-score {d['f1_score']:1.2f}\")\n",
    "    print(f'   jitter: mean {np.mean(nn_dist[nn_dist<tol]) * 1000:1.2f} ms, median {np.median(nn_dist[nn_dist<tol]) * 1000 :1.2f} ms, 95th percentile {np.percentile(nn_dist[nn_dist<tol], 95) * 1000 :1.2f} ms')\n",
    "    print(f'   jitter full: mean {np.mean(nn_dist) * 1000:1.2f} ms, median {np.median(nn_dist) * 1000 :1.2f} ms, 95th percentile {np.percentile(nn_dist, 95) * 1000 :1.2f} ms')\n",
    "    \n",
    "    nn_dist_all = np.concatenate((nn_dist_all, nn_dist))\n",
    "print(f'jitter all full: mean {np.mean(nn_dist_all) * 1000:1.2f} ms, median {np.median(nn_dist_all) * 1000 :1.2f} ms, 95th percentile {np.percentile(nn_dist_all, 95) * 1000 :1.2f} ms')\n",
    "\n",
    "plt.hist(nn_dist_all * 1000, bins=np.linspace(0, 4, 50), density=True, color=[0, .67, 0, 0.25])\n",
    "plt.axvline(np.median(nn_dist_all * 1000), color='green', label='Median')\n",
    "plt.xlabel('Temporal error [ms]')\n",
    "plt.ylabel('PDF');\n",
    "plt.xlim(0, 4)\n",
    "plt.xticks(np.arange(0, 4))\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernel_info": {
   "name": "python3"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  },
  "nteract": {
   "version": "0.24.1"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "123c3506fe0a4123a5cb4bd0ebbf0711": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "DescriptionStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "DescriptionStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "description_width": ""
      }
     },
     "2db4a4c8c4a741db818f0069a230f2f7": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_8dc0fcf8407a46b085e0cac24b4347cb",
        "IPY_MODEL_68166486a1864ac894978a614f16d0a3"
       ],
       "layout": "IPY_MODEL_3caa773b27364fd38173ed21589e962a"
      }
     },
     "3caa773b27364fd38173ed21589e962a": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "3d99753c1815404784b4f80fc71d881e": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "68166486a1864ac894978a614f16d0a3": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_tooltip": null,
       "layout": "IPY_MODEL_998c2e046fc540a69743425b74532c65",
       "placeholder": "​",
       "style": "IPY_MODEL_123c3506fe0a4123a5cb4bd0ebbf0711",
       "value": " 449/449 [16:18&lt;00:00,  2.18s/it]"
      }
     },
     "8dc0fcf8407a46b085e0cac24b4347cb": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "1.5.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "100%",
       "description_tooltip": null,
       "layout": "IPY_MODEL_3d99753c1815404784b4f80fc71d881e",
       "max": 449,
       "min": 0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_a753e1ac6662434789c649c801346837",
       "value": 449
      }
     },
     "998c2e046fc540a69743425b74532c65": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "1.2.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "1.2.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "overflow_x": null,
       "overflow_y": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "a753e1ac6662434789c649c801346837": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "1.5.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "1.5.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "1.2.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": "initial"
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
